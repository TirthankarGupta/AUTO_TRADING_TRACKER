# trading_dashboard.py
# Updated: header blue, sidebar blue, trading log on orange toggle button
import streamlit as st
import pandas as pd
import numpy as np
import requests
from datetime import datetime
import plotly.graph_objs as go

# ====== CONFIG ======
API_BASE = "http://127.0.0.1:5001"   # mock API (change to live when ready)
PAGE_TITLE = "Trading Journal"
LOT_MULTIPLIER = 1   # placeholder for position sizing
# Colors
COLOR_NAVY = "#0B2545"      # deep navy (used for header & sidebar)
COLOR_ORANGE = "#FF7A2D"    # orange (used for action button)
COLOR_WHITE = "#FFFFFF"
COLOR_GREEN = "#17A673"
COLOR_RED = "#E03E3E"

st.set_page_config(page_title=PAGE_TITLE, layout="wide", initial_sidebar_state="expanded")

# ====== GLOBAL CSS (header + sidebar + button styles) ======
st.markdown(
    f"""
<style>
/* Header already uses inline HTML, but ensure body background white */
.reportview-container .main .block-container {{
    padding-top: 0rem;
}}

/* Sidebar background (wide selector to be robust across streamlit versions) */
section[data-testid="stSidebar"] > div:first-child {{
    background: {COLOR_NAVY} !important;
    padding: 16px !important;
    color: {COLOR_WHITE} !important;
}}
/* Make sidebar inputs a little translucent on navy */
section[data-testid="stSidebar"] input, section[data-testid="stSidebar"] .stTextInput, section[data-testid="stSidebar"] .stSelectbox {{
    background: rgba(255,255,255,0.04) !important;
    color: {COLOR_WHITE} !important;
}}

/* Style primary buttons (orange) */
.stButton>button {{
    background: {COLOR_ORANGE} !important;
    color: {COLOR_WHITE} !important;
    border-radius: 8px !important;
    padding: 8px 12px !important;
    font-weight: 600 !important;
    border: none !important;
}}
/* Make the small "Place BUY Order" button keep default look but still orange */
.stButton>button:active, .stButton>button:focus {{
    outline: none !important;
}}

/* Ensure the main canvas (plot area) is white and no outer padding gap above header */
[data-testid="stAppViewContainer"] {{
    background: {COLOR_WHITE};
}}

/* Make expanders background neutral */
.stExpander {{
    background: transparent;
}}
</style>
""",
    unsafe_allow_html=True,
)

# ====== HEADER WITH LOGO (full width, navy background) ======
header_html = f"""
<div style="
  width:100%;
  background:{COLOR_NAVY};
  padding:10px 18px;
  display:flex;
  align-items:center;
  box-sizing:border-box;
">
  <div style="display:flex; align-items:center;">
    <!-- inline simple SVG Bulls & Bears icon -->
    <svg width="44" height="44" viewBox="0 0 64 64" style="margin-right:12px;">
      <circle cx="32" cy="32" r="28" fill="{COLOR_ORANGE}" />
      <path d="M20 38c6-8 18-10 28-8" fill="none" stroke="{COLOR_WHITE}" stroke-width="2"/>
      <circle cx="24" cy="24" r="4" fill="{COLOR_WHITE}"/>
    </svg>
  </div>
  <div style="color:{COLOR_WHITE}; font-weight:800; font-size:20px; line-height:1;">
    Trading Journal
  </div>
  <div style="flex:1"></div>
  <div style="color:{COLOR_WHITE}; font-size:12px; opacity:0.95;">AUTO TRADING TRACKER</div>
</div>
"""
st.markdown(header_html, unsafe_allow_html=True)

# layout: left controls (sidebar), center chart, right order+journal
sidebar = st.sidebar
sidebar.header("Controls")
symbol = sidebar.text_input("Symbol (example: NIFTY)", value="NIFTY")
timeframe = sidebar.selectbox("Timeframe", ["1m","5m","15m"], index=0)
count = sidebar.number_input("Candles (count)", min_value=20, max_value=1000, value=120, step=10)
refresh_btn = sidebar.button("Refresh now")
simulate = sidebar.checkbox("Simulate data (ignore backend)", value=False)
sidebar.markdown("---")
sidebar.write(f"Mock backend: {API_BASE}  (use real API when ready)")
sidebar.caption("Color scheme: Deep Navy Blue, Orange, White, Green")

# ----- helpers: fetch quotes and compute indicators -----
@st.cache_data(ttl=5)
def fetch_quotes(symbol: str, count: int, simulate: bool = False):
    if simulate:
        now = pd.Timestamp.now()
        t = pd.date_range(end=now, periods=count, freq="T")
        noise = np.random.normal(0, 4, size=count).cumsum()
        base = 25000 if symbol.upper().startswith("NIFTY") else 20000
        close = base + noise
        df = pd.DataFrame({"datetime": t, "open": np.roll(close,1), "high": close + np.abs(np.random.normal(0,2,size=count)),
                           "low": close - np.abs(np.random.normal(0,2,size=count)), "close": close,
                           "volume": np.random.randint(100,1000,size=count)})
        df.loc[df.index[0],"open"] = df.loc[df.index[0],"close"]
        df = df.set_index("datetime")
        return df
    # call API
    try:
        resp = requests.get(f"{API_BASE}/quote", params={"symbol": symbol, "count": count}, timeout=6)
        resp.raise_for_status()
        payload = resp.json()
        data = payload.get("data", [])
        df = pd.DataFrame(data)
        if "datetime" in df.columns:
            df["datetime"] = pd.to_datetime(df["datetime"], errors="coerce")
            df = df.set_index("datetime")
        # synthesize volume if missing
        if "volume" not in df.columns:
            vol = (df["close"].pct_change().fillna(0).abs() * 1000 + 200).round().astype(int) if "close" in df.columns else pd.Series([500]*len(df), index=df.index)
            df["volume"] = vol
        # ensure OHLC present
        if "close" not in df.columns and "price" in df.columns:
            df["close"] = df["price"]
        if "open" not in df.columns:
            df["open"] = df["close"].shift(1).fillna(df["close"])
        if "high" not in df.columns:
            df["high"] = df[["open","close"]].max(axis=1) + (df["close"] * 0.001).abs()
        if "low" not in df.columns:
            df["low"] = df[["open","close"]].min(axis=1) - (df["close"] * 0.001).abs()
        df = df[["open","high","low","close","volume"]]
        return df
    except Exception as e:
        st.sidebar.error(f"Quote fetch error: {e}")
        return pd.DataFrame(columns=["open","high","low","close","volume"])

def compute_vwap(df: pd.DataFrame):
    tp = (df["high"] + df["low"] + df["close"]) / 3.0
    pv = tp * df["volume"]
    vwap = pv.cumsum() / df["volume"].cumsum()
    return vwap

def compute_rsi(series: pd.Series, period: int = 14):
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.rolling(window=period, min_periods=1).mean()
    ma_down = down.rolling(window=period, min_periods=1).mean()
    rs = ma_up / (ma_down.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    rsi = rsi.fillna(50)
    return rsi

# ----- fetch and compute indicators -----
df = fetch_quotes(symbol, count, simulate)
if not df.empty:
    df["ema9"] = df["close"].ewm(span=9, adjust=False).mean()
    df["ema21"] = df["close"].ewm(span=21, adjust=False).mean()
    df["vwap"] = compute_vwap(df)
    df["rsi"] = compute_rsi(df["close"], period=14)

# ----- layout: main chart and right side order + journal -----
col_chart, col_right = st.columns([3,1], gap="large")

with col_chart:
    st.markdown(f"### Price chart — {symbol} ({timeframe})", unsafe_allow_html=True)
    if df.empty:
        st.info("No price data available. Try 'Simulate data' or change symbol/count.")
    else:
        last_price = df["close"].iloc[-1]
        st.metric("Last price", f"{last_price:,.2f}")

        # Plotly candlestick
        try:
            fig = go.Figure(data=[go.Candlestick(
                x=df.index,
                open=df["open"],
                high=df["high"],
                low=df["low"],
                close=df["close"],
                increasing_line_color=COLOR_GREEN,
                decreasing_line_color=COLOR_RED,
                increasing_fillcolor=COLOR_GREEN,
                decreasing_fillcolor=COLOR_RED,
                showlegend=False
            )])
            # overlay EMA9, EMA21, VWAP
            fig.add_trace(go.Scatter(x=df.index, y=df["ema9"], mode="lines", name="EMA9",
                                     line=dict(color=COLOR_NAVY, width=1.8)))
            fig.add_trace(go.Scatter(x=df.index, y=df["ema21"], mode="lines", name="EMA21",
                                     line=dict(color=COLOR_ORANGE, width=1.8)))
            fig.add_trace(go.Scatter(x=df.index, y=df["vwap"], mode="lines", name="VWAP",
                                     line=dict(color="#6C757D", width=1.6, dash="dash")))
            # layout style: white background, no gridlines
            fig.update_layout(
                paper_bgcolor=COLOR_WHITE,
                plot_bgcolor=COLOR_WHITE,
                margin=dict(l=20, r=20, t=10, b=40),
                height=560,
                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
            )
            fig.update_xaxes(title_text="Time", showgrid=False, zeroline=False, tickangle=0)
            fig.update_yaxes(title_text="Price", showgrid=False, zeroline=False)
            st.plotly_chart(fig, use_container_width=True)
        except Exception as e:
            st.error(f"Chart render error: {e}")
            st.line_chart(df["close"])

    # Indicators panel under chart
    with st.expander("Indicators (EMA9, EMA21, VWAP, RSI)", expanded=True):
        if df.empty:
            st.write("No indicators to show.")
        else:
            st.write(f"- EMA9 latest: {df['ema9'].iloc[-1]:.2f}")
            st.write(f"- EMA21 latest: {df['ema21'].iloc[-1]:.2f}")
            st.write(f"- VWAP latest: {df['vwap'].iloc[-1]:.2f}")
            st.write(f"- RSI(14) latest: {df['rsi'].iloc[-1]:.2f}")

with col_right:
    st.markdown("## Order panel (CE / PE BUY only)")
    option_type = st.selectbox("Option Type", ["CE","PE"])
    atm = st.checkbox("Use ATM strike (auto)", value=True)
    if not df.empty:
        last_close = float(df["close"].iloc[-1])
    else:
        last_close = None

    if atm and last_close is not None:
        strike = int(round(last_close))
        st.write(f"ATM strike chosen: **{strike}**")
    else:
        strike = st.number_input("Strike price", value=25000, step=50)

    qty = st.number_input("Qty / lots", value=1, min_value=1)

    if st.button("Place BUY Order"):
        payload = {"symbol": symbol, "type": option_type, "strike": int(strike), "qty": int(qty)}
        try:
            r = requests.post(f"{API_BASE}/place_order", json=payload, timeout=5)
            r.raise_for_status()
            res = r.json()
            st.success(f"Order placed: {res.get('order_id')}")
        except Exception as e:
            st.error(f"Order failed: {e}")
            res = {"status": "error", "error": str(e)}
        # append to journal (session_state)
        if "journal" not in st.session_state:
            st.session_state.journal = []
        entry = {
            "id": res.get("order_id", f"LOCAL-{int(datetime.now().timestamp()*1000)}"),
            "time": datetime.now().isoformat(),
            "symbol": symbol,
            "type": option_type,
            "strike": int(strike),
            "qty": int(qty),
            "entry_price": last_close if last_close is not None else None,
            "exit_price": None,
            "status": "open" if res.get("status")=="ok" else "error",
            "response": res
        }
        st.session_state.journal.insert(0, entry)

    st.markdown("---")

    # Orange button to toggle trading log visibility
    if "show_log" not in st.session_state:
        st.session_state.show_log = True
    if st.button("Show / Hide Trading Log", key="toggle_log"):
        st.session_state.show_log = not st.session_state.show_log

    # Render journal only if toggled on
    if st.session_state.show_log:
        st.subheader("Trading Journal")
        if "journal" not in st.session_state:
            st.session_state.journal = []

        # PnL helpers
        def compute_pnl(entry, current_price):
            if entry["entry_price"] is None:
                return None
            if entry["exit_price"] is not None:
                pnl = (entry["exit_price"] - entry["entry_price"]) * entry["qty"] * LOT_MULTIPLIER
            else:
                pnl = (current_price - entry["entry_price"]) * entry["qty"] * LOT_MULTIPLIER
            return pnl

        if len(st.session_state.journal) == 0:
            st.write("No trades in journal yet.")
        else:
            rows = []
            for idx, e in enumerate(st.session_state.journal):
                current_price = df["close"].iloc[-1] if (not df.empty) else None
                pnl = compute_pnl(e, current_price) if current_price is not None else None
                rows.append({
                    "index": idx,
                    "id": e["id"],
                    "time": e["time"],
                    "symbol": e["symbol"],
                    "type": e["type"],
                    "strike": e["strike"],
                    "qty": e["qty"],
                    "entry_price": e["entry_price"],
                    "exit_price": e["exit_price"],
                    "status": e["status"],
                    "pnl": round(pnl,2) if pnl is not None else None
                })

            for r in rows:
                with st.expander(f"{r['time']} — {r['symbol']} {r['type']} {r['strike']} qty={r['qty']}"):
                    st.write(pd.DataFrame([r]).drop(columns=["index"]))
                    if r["status"] == "open":
                        if st.button(f"Close trade {r['id']}", key=f"close_{r['index']}"):
                            exit_price = df["close"].iloc[-1] if not df.empty else None
                            st.session_state.journal[r["index"]]["exit_price"] = exit_price
                            st.session_state.journal[r["index"]]["status"] = "closed"
                            st.success(f"Trade {r['id']} closed at {exit_price}")
                            st.experimental_rerun()

            # Export CSV
            if st.button("Export Journal CSV"):
                out_df = pd.DataFrame(st.session_state.journal)
                csv = out_df.to_csv(index=False)
                st.download_button("Download CSV", data=csv, file_name=f"trading_journal_{symbol}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv", mime="text/csv")

        # Running summary PnL
        if not df.empty and st.session_state.journal:
            total_unreal = 0.0
            total_real = 0.0
            for e in st.session_state.journal:
                if e["entry_price"] is None:
                    continue
                if e["exit_price"] is not None:
                    total_real += (e["exit_price"] - e["entry_price"]) * e["qty"] * LOT_MULTIPLIER
                else:
                    total_unreal += (df["close"].iloc[-1] - e["entry_price"]) * e["qty"] * LOT_MULTIPLIER
            st.markdown("---")
            st.metric("Unrealized PnL", f"{total_unreal:.2f}", delta=None)
            st.metric("Realized PnL", f"{total_real:.2f}", delta=None)

# Footer spacing
st.markdown("<div style='height:16px'></div>", unsafe_allow_html=True)
